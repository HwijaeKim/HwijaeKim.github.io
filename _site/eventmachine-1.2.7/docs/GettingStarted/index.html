<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="ko-KR" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>@title Getting Started with Ruby EventMachine - HWIJAE KIM</title>
<meta name="description" content="">


  <meta name="author" content="김휘재 Hwijae Kim">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="HWIJAE KIM">
<meta property="og:title" content="@title Getting Started with Ruby EventMachine">
<meta property="og:url" content="http://localhost:4000/eventmachine-1.2.7/docs/GettingStarted/">


  <meta property="og:description" content="">











  

  


<link rel="canonical" href="http://localhost:4000/eventmachine-1.2.7/docs/GettingStarted/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="HWIJAE KIM Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  window.enable_copy_code_button = true;
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<!--<link rel="stylesheet" href="/assets/css/main_dark.css">-->
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<link rel="icon" type="image/png" href="/assets/images/ico/favicon-48x48.png" sizes="48x48" />
<link rel="icon" type="image/svg+xml" href="/assets/images/ico/favicon.svg" />
<link rel="shortcut icon" href="/assets/images/ico/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/ico/apple-touch-icon.png" />
<link rel="manifest" href="/assets/images/ico/site.webmanifest" />

<!-- end custom head snippets -->

  </head>

  <body class="layout--default" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          HWIJAE KIM
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about"
                
                
              >이력서/자기소개서</a>
            </li><li class="masthead__menu-item">
              <a
                href="/recent-posts"
                
                
              >최근 게시물</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">토글 메뉴</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>

    </div>
  </div>
</div>


    <div class="initial-content">
      <h1 id="title-getting-started-with-ruby-eventmachine">@title Getting Started with Ruby EventMachine</h1>
<h1 id="markup-markdown">@markup markdown</h1>
<h1 id="author-michael-s-klishin-dan-sinclair">@author Michael S. Klishin, Dan Sinclair</h1>

<h1 id="getting-started-with-ruby-eventmachine">Getting started with Ruby EventMachine</h1>

<h2 id="about-this-guide">About this guide</h2>

<p>This guide is a quick tutorial that helps you to get started with EventMachine for writing event-driven
servers, clients and using it as a lightweight concurrency library.
It should take about 20 minutes to read and study the provided code examples. This guide covers</p>

<ul>
  <li>Installing EventMachine via <a href="http://rubygems.org">Rubygems</a> and <a href="http://gembundler.com">Bundler</a>.</li>
  <li>Building an Echo server, the “Hello, world”-like code example of network servers.</li>
  <li>Building a simple chat, both server and client.</li>
  <li>Building a very small asynchronous Websockets client.</li>
</ul>

<h2 id="covered-versions">Covered versions</h2>

<p>This guide covers EventMachine v0.12.10 and 1.0 (including betas).</p>

<h2 id="level">Level</h2>

<p>This guide assumes you are comfortable (but not necessary a guru) with the command line. On Microsoft Windows™,
we recommend you to use <a href="http://jruby.org">JRuby</a> when running these examples.</p>

<h2 id="installing-eventmachine">Installing EventMachine</h2>

<h3 id="make-sure-you-have-ruby-installed">Make sure you have Ruby installed</h3>

<p>This guide assumes you have one of the supported Ruby implementations installed:</p>

<ul>
  <li>Ruby 1.8.7</li>
  <li>Ruby 1.9.2</li>
  <li><a href="http://jruby.org">JRuby</a> (we recommend 1.6)</li>
  <li><a href="http://rubini.us">Rubinius</a> 1.2 or higher</li>
  <li><a href="http://www.rubyenterpriseedition.com">Ruby Enterprise Edition</a></li>
</ul>

<p>EventMachine works on Microsoft Windows™.</p>

<h3 id="with-rubygems">With Rubygems</h3>

<p>To install the EventMachine gem do</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem install eventmachine
</code></pre></div></div>

<h3 id="with-bundler">With Bundler</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem "eventmachine"
</code></pre></div></div>

<h3 id="verifying-your-installation">Verifying your installation</h3>

<p>Lets verify your installation with this quick IRB session:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb -rubygems

ruby-1.9.2-p180 :001 &gt; require "eventmachine"
 =&gt; true
ruby-1.9.2-p180 :002 &gt; EventMachine::VERSION
 =&gt; "1.0.0.beta.3"
</code></pre></div></div>

<h2 id="an-echo-server-example">An Echo Server Example</h2>

<p>Lets begin with the classic “Hello, world”-like example, an echo server. The echo server responds clients with the
same data that was provided. First, here’s the code:</p>

<p>{include:file:examples/guides/getting_started/01_eventmachine_echo_server.rb}</p>

<p>When run, the server binds to port 10000. We can connect using Telnet and verify it’s working:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>telnet localhost 10000
</code></pre></div></div>

<p>On my machine the output looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ telnet localhost 10000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</code></pre></div></div>

<p>Let’s send something to our server. Type in “Hello, EventMachine” and hit Enter. The server will respond with
the same string:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ telnet localhost 10000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Hello, EventMachine
# (here we hit Enter)
Hello, EventMachine
# (this ^^^ is our echo server reply)
</code></pre></div></div>

<p>It works! Congratulations, you now can tell your Node.js-loving friends that you “have done some event-driven programming, too”.
Oh, and to stop Telnet, hit Control + Shift + ] and then Control + C.</p>

<p>Lets walk this example line by line and see what’s going on. These lines</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require 'rubygems' # or use Bundler.setup
require 'eventmachine'
</code></pre></div></div>

<p>probably look familiar: you use <a href="http://rubygems.org">RubyGems</a> (or <a href="http://gembundler.com/">Bundler</a>) for dependencies and then require EventMachine gem. Boring.</p>

<p>Next:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class EchoServer &lt; EventMachine::Connection
  def receive_data(data)
    send_data(data)
  end
end
</code></pre></div></div>

<p>Is the implementation of our echo server. We define a class that inherits from {EventMachine::Connection}
and a handler (aka callback) for one event: when we receive data from a client.</p>

<p>EventMachine handles the connection setup, receiving data and passing it to our handler, {EventMachine::Connection#receive_data}.</p>

<p>Then we implement our protocol logic, which in the case of Echo is pretty trivial: we send back whatever we receive.
To do so, we’re using {EventMachine::Connection#send_data}.</p>

<p>Lets modify the example to recognize <code class="language-plaintext highlighter-rouge">exit</code> command:</p>

<p>{include:file:examples/guides/getting_started/02_eventmachine_echo_server_that_recognizes_exit_command.rb}</p>

<p>Our <code class="language-plaintext highlighter-rouge">receive\_data</code> changed slightly and now looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def receive_data(data)
  if data.strip =~ /exit$/i
    EventMachine.stop_event_loop
  else
    send_data(data)
  end
end
</code></pre></div></div>

<p>Because incoming data has trailing newline character, we strip it off before matching it against a simple regular
expression. If the data ends in <code class="language-plaintext highlighter-rouge">exit</code>, we stop EventMachine event loop with {EventMachine.stop_event_loop}. This unblocks
main thread and it finishes execution, and our little program exits as the result.</p>

<p>To summarize this first example:</p>

<ul>
  <li>Subclass {EventMachine::Connection} and override {EventMachine::Connection#send_data} to handle incoming data.</li>
  <li>Use {EventMachine.run} to start EventMachine event loop and then bind echo server with {EventMachine.start_server}.</li>
  <li>To stop the event loop, use {EventMachine.stop_event_loop} (aliased as {EventMachine.stop})</li>
</ul>

<p>Lets move on to a slightly more sophisticated example that will introduce several more features and methods
EventMachine has to offer.</p>

<h2 id="a-simple-chat-server-example">A Simple Chat Server Example</h2>

<p>Next we will write a simple chat. Initially clients will still use telnet to connect, but then we will add little
client application that will serve as a proxy between telnet and the chat server. This example is certainly longer
(~ 150 lines with whitespace and comments) so instead of looking at the final version and going through it line by line,
we will instead begin with a very simple version that only keeps track of connected clients and then add features
as we go.</p>

<p>To set some expectations about our example:</p>

<ul>
  <li>It will keep track of connected clients</li>
  <li>It will support a couple of commands, à la IRC</li>
  <li>It will support direct messages using Twitter-like @usernames</li>
  <li>It won’t use MongoDB, fibers or distributed map/reduce for anything but will be totally <a href="http://bit.ly/webscaletm">Web Scale™</a> nonetheless. Maybe even <a href="http://bit.ly/roflscalevideo">ROFLscale</a>.</li>
</ul>

<h3 id="step-one-detecting-connections-and-disconnectons">Step one: detecting connections and disconnectons</h3>

<p>First step looks like this:</p>

<p>{include:file:examples/guides/getting_started/04_simple_chat_server_step_one.rb}</p>

<p>We see familiar {EventMachine.run} and {EventMachine.start_server}, but also {EventMachine::Connection#post_init} and {EventMachine::Connection#unbind} we haven’t
met yet. We don’t use them in this code, so when are they run? Like {EventMachine::Connection#receive_data}, these methods are callbacks. EventMachine calls them
when certain events happen:</p>

<ul>
  <li>{EventMachine#post_init} is called by the event loop immediately after the network connection has been established.
In the chat server example case, this is when a new client connects.</li>
  <li>{EventMachine#unbind} is called when client disconnects, connection is closed or is lost (because of a network issue, for example).</li>
</ul>

<p>All our chat server does so far is logging connections or disconnections. What we want it to do next is to keep track of connected clients.</p>

<h3 id="step-two-keep-track-of-connected-clients">Step two: keep track of connected clients</h3>

<p>Next iteration of the code looks like this:</p>

<p>{include:file:examples/guides/getting_started/05_simple_chat_server_step_two.rb}</p>

<p>While the code we added is very straightforward, we have to clarify one this first: subclasses of {EventMachine::Connection} are instantiated by
EventMachine for every new connected peer. So for 10 connected chat clients, there will be 10 separate <code class="language-plaintext highlighter-rouge">SimpleChatServer</code> instances in our
server process. Like any other objects, they can be stored in a collection, can provide public API other objects use, can instantiate or inject
dependencies and in general live a happy life all Ruby objects live until garbage collection happens.</p>

<p>In the example above we use a @@class_variable to keep track of connected clients. In Ruby, @@class variables are accessible from instance
methods so we can add new connections to the list from <code class="language-plaintext highlighter-rouge">SimpleChatServer#post_init</code> and remove them in <code class="language-plaintext highlighter-rouge">SimpleChatServer#unbind</code>. We can also
filter connections by some criteria, as <code class="language-plaintext highlighter-rouge">SimpleChatServer#other_peers demonstrates</code>.</p>

<p>So, we keep track of connections but how do we identify them? For a chat app, it’s pretty common to use usernames for that. Lets ask our clients
to enter usernames when they connect.</p>

<h3 id="step-three-adding-usernames">Step three: adding usernames</h3>

<p>To add usernames, we need to add a few things:</p>

<ul>
  <li>We need to invite newly connected clients to enter their username.</li>
  <li>A reader (getter) method on our {EventMachine::Connection} subclass.</li>
  <li>An idea of connection state (keeping track of whether a particular participant had entered username before).</li>
</ul>

<p>Here is one way to do it:</p>

<p>{include:file:examples/guides/getting_started/06_simple_chat_server_step_three.rb}</p>

<p>This is quite an update so lets take a look at each method individually. First, <code class="language-plaintext highlighter-rouge">SimpleChatServer#post_init</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def post_init
  @username = nil
  puts "A client has connected..."
  ask_username
end
</code></pre></div></div>

<p>To keep track of username we ask chat participants for, we add @username instance variable to our connection class. Connection
instances are just Ruby objects associated with a particular connected peer, so using @ivars is very natural. To make username
value accessible to other objects, we added a reader method that was not shown on the snippet above.</p>

<p>Lets dig into <code class="language-plaintext highlighter-rouge">SimpleChatServer#ask_username</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def ask_username
  self.send_line("[info] Enter your username:")
end # ask_username

# ...

def send_line(line)
  self.send_data("#{line}\n")
end # send_line(line)
</code></pre></div></div>

<p>Nothing new here, we are using {EventMachine::Connection#send_data} which we have seen before.</p>

<p>In <code class="language-plaintext highlighter-rouge">SimpleChatServer#receive_data</code> we now have to check if the username was entered or we need
to ask for it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def receive_data(data)
  if entered_username?
    handle_chat_message(data.strip)
  else
    handle_username(data.strip)
  end
end

# ...

def entered_username?
  !@username.nil? &amp;&amp; !@username.empty?
end # entered_username?
</code></pre></div></div>

<p>Finally, handler of chat messages is not yet implemented:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def handle_chat_message(msg)
  raise NotImplementedError
end
</code></pre></div></div>

<p>Lets try this example out using Telnet:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ telnet localhost 10000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
[info] Enter your username:
antares_
[info] Ohai, antares_
</code></pre></div></div>

<p>and the server output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A client has connected...
antares_ has joined
</code></pre></div></div>

<p>This version requires you to remember how to terminate your Telnet session (Ctrl + Shift + ], then Ctrl + C).
It is annoying, so why don’t we add the same <code class="language-plaintext highlighter-rouge">exit</code> command to our chat server?</p>

<h3 id="step-four-adding-exit-command-and-delivering-chat-messages">Step four: adding exit command and delivering chat messages</h3>

<p>{include:file:examples/guides/getting_started/07_simple_chat_server_step_four.rb}</p>

<p>TBD</p>

<p>Lets test-drive this version. Client A:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ telnet localhost 10000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
[info] Enter your username:
michael
[info] Ohai, michael
Hi everyone
michael: Hi everyone
joe has joined the room
# here ^^^ client B connects, lets greet him
hi joe
michael: hi joe
joe: hey michael
# ^^^ client B replies
exit
# ^^^ out command in action
Connection closed by foreign host.
</code></pre></div></div>

<p>Client B:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ telnet localhost 10000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
[info] Enter your username:
joe
[info] Ohai, joe
michael: hi joe
# ^^^ client A greets us, lets reply
hey michael
joe: hey michael
exit
# ^^^ out command in action
Connection closed by foreign host.
</code></pre></div></div>

<p>And finally, the server output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A client has connected...
michael has joined
A client has connected...
_antares has joined
[info] _antares has left
[info] michael has left
</code></pre></div></div>

<p>Our little char server now supports usernames, sending messages and the <code class="language-plaintext highlighter-rouge">exit</code> command. Next up, private (aka direct) messages.</p>

<h3 id="step-five-adding-direct-messages-and-one-more-command">Step five: adding direct messages and one more command</h3>

<p>To add direct messages, we come up with a simple convention: private messages begin with @username and may have optional colon before
message text, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@joe: hey, how do you like eventmachine?
</code></pre></div></div>

<p>This convention makes parsing of messages simple so that we can concentrate on delivering them to a particular client connection.
Remember when we added <code class="language-plaintext highlighter-rouge">username</code> reader on our connection class? That tiny change makes this step possible: when a new direct
message comes in, we extract username and message text and then find then connection for @username in question:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#
# Message handling
#
  
def handle_chat_message(msg)
  if command?(msg)
    self.handle_command(msg)
  else
    if direct_message?(msg)
      self.handle_direct_message(msg)
    else
      self.announce(msg, "#{@username}:")
    end
  end
end # handle_chat_message(msg)
  
def direct_message?(input)
  input =~ DM_REGEXP
end # direct_message?(input)
  
def handle_direct_message(input)
  username, message = parse_direct_message(input)
  
  if connection = @@connected_clients.find { |c| c.username == username }
    puts "[dm] @#{@username} =&gt; @#{username}"
    connection.send_line("[dm] @#{@username}: #{message}")
  else
    send_line "@#{username} is not in the room. Here's who is: #{usernames.join(', ')}"
  end
end # handle_direct_message(input)
  
def parse_direct_message(input)
  return [$1, $2] if input =~ DM_REGEXP
end # parse_direct_message(input)
</code></pre></div></div>

<p>This snippet demonstrates how one connection instance can obtain another connection instance and send data to it.
This is a very powerful feature, consider just a few use cases:</p>

<ul>
  <li>Peer-to-peer protocols</li>
  <li>Content-aware routing</li>
  <li>Efficient streaming with optional filtering</li>
</ul>

<p>Less common use cases include extending C++ core of EventMachine to provide access to  hardware that streams events that
can be re-broadcasted to any interested parties connected via TCP, UDP or something like AMQP or WebSockets. With this,
sky is the limit. Actually, EventMachine has several features for efficient proxying data between connections.
We will not cover them in this guide.</p>

<p>One last feature that we are going to add to our chat server is the <code class="language-plaintext highlighter-rouge">status</code> command that tells you current server time and how many people
are there in the chat room:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#
# Commands handling
#
  
def command?(input)
  input =~ /(exit|status)$/i
end # command?(input)
  
def handle_command(cmd)
  case cmd
  when /exit$/i   then self.close_connection
  when /status$/i then self.send_line("[chat server] It's #{Time.now.strftime('%H:%M')} and there are #{self.number_of_connected_clients} people in the room")
  end
end # handle_command(cmd)
</code></pre></div></div>

<p>Hopefully this piece of code is easy to follow. Try adding a few more commands, for example, the <code class="language-plaintext highlighter-rouge">whoishere</code> command that lists people
currently in the chat room.</p>

<p>In the end, our chat server looks like this:</p>

<p>{include:file:examples/guides/getting_started/08_simple_chat_server_step_five.rb}</p>

<p>We are almost done with the server but there are some closing thoughts.</p>

<h3 id="step-six-final-version">Step six: final version</h3>

<p>Just in case, here is the final version of the chat server code we have built:</p>

<p>{include:file:examples/guides/getting_started/03_simple_chat_server.rb}</p>

<h3 id="step-seven-future-directions-and-some-closing-thoughts">Step seven: future directions and some closing thoughts</h3>

<p>The chat server is just about 150 lines of Ruby including empty lines and comments, yet it has a few features most of chat server
examples never add. We did not, however, implement many other features that popular IRC clients like <a href="http://colloquy.info">Colloquy</a> have:</p>

<ul>
  <li>Chat moderation</li>
  <li>Multiple rooms</li>
  <li>Connection timeout detection</li>
</ul>

<p>How would one go about implementing them? We thought it is worth discussing what else EventMachine has to offer and what ecosystem projects
one can use to build a really feature-rich Web-based IRC chat client.</p>

<p>With multiple rooms it’s more or less straightforward, just add one more hash and a bunch of commands and use the information about which rooms participant
is in when you are delivering messages. There is nothing in EventMachine itself that can make the job much easier for developer.</p>

<p>To implement chat moderation feature you may want to do a few things:</p>

<ul>
  <li>Work with client IP addresses. Maybe we want to consider everyone who connects from certain IPs a moderator.</li>
  <li>Access persistent data about usernames of moderators and their credentials.</li>
</ul>

<p>Does EventMachine have anything to offer here? It does. To obtain peer IP address, take a look at {EventMachine::Connection#get_peername}. The name of this method is
a little bit misleading and originates from low-level socket programming APIs.</p>

<h4 id="a-whirlwind-tour-of-the-eventmachine-ecosystem">A whirlwind tour of the EventMachine ecosystem</h4>

<p>To work with data stores you can use several database drivers that ship with EventMachine itself, however, quite often there are some 3rd party projects in
the EventMachine ecosystem that have more features, are faster or just better maintained. So we figured it will be helpful to provide a few pointers
to some of those projects:</p>

<ul>
  <li>For MySQL, check out <a href="https://github.com/eventmachine/em-mysql">em-mysql</a> project.</li>
  <li>For PostgreSQL, have a look at Mike Perham’s <a href="https://github.com/mperham/em_postgresql">EventMachine-based PostgreSQL driver</a>.</li>
  <li>For Redis, there is a young but already popular <a href="https://github.com/mloughran/em-hiredis">em-hiredis</a> library that combines EventMachine’s non-blocking I/O with
extreme performance of the official Redis C client, <a href="https://github.com/antirez/hiredis">hiredis</a>.</li>
  <li>For MongoDB, see <a href="https://github.com/bcg/em-mongo">em-mongo</a></li>
  <li>For Cassandra, Mike Perham <a href="http://www.mikeperham.com/2010/02/09/cassandra-and-eventmachine/">added transport agnosticism feature</a> to the <a href="https://rubygems.org/gems/cassandra">cassandra gem</a>.</li>
</ul>

<p><a href="http://www.basho.com/products_riak_overview.php">Riak</a> and CouchDB talk HTTP so it’s possible to use <a href="https://github.com/igrigorik/em-http-request">em-http-request</a>.
If you are aware of EventMachine-based non-blocking drivers for these databases, as well as for HBase, let us know on the <a href="http://groups.google.com/group/eventmachine">EventMachine mailing list</a>.
Also, EventMachine supports TLS (aka SSL) and works well on <a href="http://jruby.org">JRuby</a> and Windows.</p>

<p>Learn more in our {file:docs/Ecosystem.md EventMachine ecosystem} and {file:docs/TLS.md TLS (aka SSL)} guides.</p>

<h4 id="connection-loss-detection">Connection loss detection</h4>

<p>Finally, connection loss detection. When our chat participant closes her laptop lid, how do we know that she is no longer active? The answer is, when EventMachine
detects TCP connectin closure, it calls {EventMachine::Connection#unbind}. Version 1.0.beta3 and later also pass an optional argument to that method. The argument
indicates what error (if any) caused the connection to be closed.</p>

<p>Learn more in our {file:docs/ConnectionFailureAndRecovery.md Connection Failure and Recovery} guide.</p>

<h4 id="what-the-chat-server-example-doesnt-demonstrate">What the Chat Server Example doesn’t demonstrate</h4>

<p>This chat server also leaves out something production quality clients and servers must take care of: buffering. We intentionally did not include any buffering in
our chat server example: it would only distract you from learning what you really came here to learn: how to use EventMachine to build blazing fast asynchronous
networking programs quickly. However, {EventMachine::Connection#receive_data} does not offer any guarantees that you will be receiving “whole messages” all the time,
largely because the underlying transport (UDP or TCP) does not offer such guarantees. Many protocols, for example, AMQP, mandate that large content chunks are
split into smaller <em>frames</em> of certain size. This means that <a href="https://github.com/ruby-amqp/amq-client">amq-client</a> library, for instance, that has EventMachine-based driver,
has to deal with figuring out when exactly we received “the whole message”. To do so, it uses buffering and employs various checks to detect <em>frame boundaries</em>.
So <strong>don’t be deceived by the simplicity of this chat example</strong>: it intentionally leaves framing out, but real world protocols usually require it.</p>

<h2 id="a-proxying-chat-client-example">A (Proxying) Chat Client Example</h2>

<p>TBD</p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>This tutorial ends here. Congratulations! You have learned quite a bit about EventMachine.</p>

<h2 id="what-to-read-next">What to read next</h2>

<p>The documentation is organized as a {file:docs/DocumentationGuidesIndex.md number of guides}, covering all kinds of
topics. TBD</p>

<h2 id="tell-us-what-you-think">Tell us what you think!</h2>

<p>Please take a moment and tell us what you think about this guide on the <a href="http://bit.ly/jW3cR3">EventMachine mailing list</a>
or in the #eventmachine channel on irc.freenode.net: what was unclear? What wasn’t covered?
Maybe you don’t like the guide style or the grammar and spelling are incorrect? Reader feedback is
key to making documentation better.</p>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="검색어를 입력하세요..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>팔로우:</strong></li>
    

    
      
        
          <li><a href="https://github.com/HwijaeKim/hwijaekim.github.io.git" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-git-alt" aria-hidden="true"></i> Git</a></li>
        
      
        
          <li><a href="https://github.com/HwijaeKim" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-square-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://linkedin.com/in/hwijaekim" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">HWIJAE KIM</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>






  </body>
</html>
